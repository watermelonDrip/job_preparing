# 双指针

## 剑指 Offer 57.1 和为s的两个数字

在递增数组里找一对和为s的数字。

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        left = 0
        right = len(nums)-1
        while left<right:
            if nums[left]+ nums[right]>target:
                right-=1
            elif nums[left] + nums[right] < target:
                left+=1
            else:
                return [nums[left],nums[right]]
```


## 剑指 Offer 57.2 和为s的两个数字

输出所有和为 S 的连续正数序列。  (左右端点）

模版：
```python
l,r = 0,n-1
while l <r:
    if (找到了):
        return value
    if condition1:
        l+=1
    else:
        r-=1
```

```python
class Solution:
    def findContinuousSequence(self, target: int) -> List[List[int]]:
        l,r,s = 1,2,3
        res = list()
        while l < r:
            if s == target:
                res.append(list(range(l,r+1)))
            if s>=target:
                s-=l
                l+=1
            else:
                r+=1
                s+=r
        return res
```
T：O(n)
S: O(1)


## 剑指 Offer 58 左旋转字符串

实现字符串左旋转操作的功能

```python
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        def reverseWord(s):
            left = 0
            right = len(s)-1
            while left<right:
                s[left],s[right] = s[right],s[left]
                left+=1
                right-=1
            return s
             
        s = list(s)
        s[:n] = reverseWord(s[:n])
        s[n:] = reverseWord(s[n:])
        s = reverseWord(s)
        return ''.join(s)
```
T: O(n)
S:O(1)

## Offer 25. 合并两个排序的链表

合并两个递增排序的链表，合并这个两个链表，形成一个新链表

```python
 
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = ListNode()
        tmp = head
        while l1 and l2:
            if l1.val> l2.val:
                tmp.next = l2
                l2 = l2.next
                tmp = tmp.next
            else:
                tmp.next = l1
                l1 = l1.next
                tmp = tmp.next
        if l1:
            tmp.next = l1
        else:
            tmp.next = l2
        return head.next

```
T:O(n)
S:O(n)
