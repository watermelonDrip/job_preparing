# 模拟、枚举与递推

### 模拟机器人行走
```python
class Solution:
    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
        dx = [0,1,0,-1]
        dy = [1,0,-1,0]
        di = 0
        x,y = 0,0
        ans = 0
        obstacleset = set(map(tuple,obstacles))
        for cmd in commands:
            if cmd == -1:
                di = (di+1)%4
            elif cmd == -2:
                di = (di-1)%4
            else:
                for _ in range(cmd):
                    if (x+dx[di],y+dy[di]) not in obstacleset:
                         
                        x += dx[di]
                        y += dy[di]
                        ans = max(ans, x**2 + y**2)
        return ans
```

### 倒香槟

```python
class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        dp = [ [0 for _ in range(102)] for _ in range(102)]
        dp[0][0] = poured
        for i in range(query_row+1):
            for j in range(i+1):
                q = (dp[i][j] - 1)/2
                if q>0:
                    dp[i+1][j] += q
                    dp[i+1][j+1]+=q
                
        return min(1, dp[query_row][query_glass])
```



### 枚举三要素

+ 状态 
+ 不重不漏
+ 效率



## 递推

base case 

# 排序算法

# 二分查找

给定一个有序数组nums,给定一个数字target，target的索引。

+ 解空间
+ 有序
+ 极值 （静态）

## 一个中心

+ 什么条件
+ 舍弃哪部分

## 常见题型
### 查找一个数

#### 思维框架
+ 定义搜索区间[left,right]
+ nums[mid]与目标比对：1. 如果nums[mid] == target: return。2.小于,[mid+1,right] 3.大于[left,mid-1]
```python
def binarySearch(nums, target): # [l, r]
    l, r = 0, len(nums) - 1 
    while l <= r:
        mid = (left + right) >> 1
        if nums[mid] == target: return mid
        #            [mid+1, right]
        if nums[mid] < target: l = mid + 1
        #            [left, mid - 1]
        if nums[mid] > target: r = mid - 1
return -1
```

### 寻找最左边的满足条件的数 (最左返回左）（最右返回右）
#### 思维框架
+ 定义搜索区间[left,right]
+ nums[mid]与目标比对：1. 如果nums[mid] == target: 收缩右边。2.小于,[mid+1,right] 3.大于[left,mid-1]

```python
def binarySearchLeft(nums, target): # [l, r]
    l, r = 0, len(nums) - 1
    while l <= r:
        mid = (l + r) >> 1
        if nums[mid] == target: # 收缩右边
            r = mid - 1;
        #            [mid+1, right]
        if nums[mid] < target: l = mid + 1
        #            [left, mid - 1]
        if nums[mid] > target: r = mid - 1
    if l >= len(nums) or nums[l] != target: return -1
    return l
```


### 寻找最右边的满足条件的数

#### 思维框架
+ 定义搜索区间[left,right]
+ nums[mid]与目标比对：1. 如果nums[mid] == target: 收缩左边。2.小于,[mid+1,right] 3.大于[left,mid-1]

```python 
def binarySearchRight(nums, target): # [l, r]
    l, r = 0, len(nums) - 1
    while l <= r:
        mid = (l + r) >> 1
        if nums[mid] == target:
            l = mid + 1;
        #            [mid+1, right]
        if nums[mid] < target: l = mid + 1
        #            [left, mid - 1]
        if nums[mid] > target: r = mid - 1
    if r < 0 or nums[r] != target: return -1
    return r
```


### 寻找最左插入位置

 

#### 思维框架
+ 寻找最右满足小于x的位置+1
#### 思维框架
+ 定义搜索区间[left,right]
+ nums[mid]与目标比对：1. 如果nums[mid] == target: 收缩左边。2.小于,[mid+1,right] 3.大于[left,mid-1]

```python
def bisect_left(nums, x): 
# api
    bisect.bisect_left(nums, x)
# 手写
    l, r = 0, len(A) - 1
    while l <= r:
        mid = (l + r) // 2
        if A[mid] >= x: r = mid - 1
        else: l = mid + 1
return l
```

### 寻找最右插入位置

 

#### 思维框架
+ 寻找最左满足大于x的位置
#### 思维框架
+ 定义搜索区间[left,right]
+ nums[mid]与目标比对：1. 如果nums[mid] == target: 收缩左边。2.小于,[mid+1,right] 3.大于[left,mid-1]

```python
def bisect_left(nums, x): 
# api
    bisect.bisect_left(nums, x)
# 手写
    l, r = 0, len(A) - 1
    while l <= r:
        mid = (l + r) // 2
        if A[mid] <= x: l = mid + 1
        else: r = mid - 1
return l
```

