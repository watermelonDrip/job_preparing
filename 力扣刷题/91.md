414. 第三大数
```python
class Solution:
    import heapq as hq
    def thirdMax(self, nums: List[int]) -> int:
        heap = list()
        for i in range(len(nums)):
            if nums[i] in heap:
                continue
            heapq.heappush(heap,nums[i])
            if len(heap)>3:
                heapq.heappop(heap)
        if len(heap)<3:
            return max(heap)
        else:
            return min(heap)
```
```python
class Solution:
    import heapq as hq
    def thirdMax(self, nums: List[int]) -> int:
        heap = list()
        if len(set(nums))<3:
            return max(nums)
        for num in set(nums):
            heappush(heap,num)
            if len(heap)>3:
                heappop(heap)
        return heap[0]
```
150. 逆波兰表达式
```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        heap = []
        for i in range(len(tokens)):
            if tokens[i].lstrip('-').isdigit(): #注意
                heap.append(int(tokens[i]))
            else:
                a = heap.pop(-1)
                b = heap.pop(-1)
                if tokens[i] == '+':
                    c = a+ b
                elif tokens[i] == '*':
                    c = a*b
                elif tokens[i] == '-':
                    c = b-a
                elif tokens[i] == '/':
                    c = b/a
                 
                heap.append(int(c))
             
        return heap[-1]
```        

1381.
```python
class CustomStack:

    def __init__(self, maxSize: int):
        self.stk = []
        self.maxSize = maxSize

    def push(self, x: int) -> None:
        if len(self.stk)< self.maxSize:
            self.stk.append(x)
        



    def pop(self) -> int:
        if len(self.stk) == 0:
            return -1
        else:
            tmp = self.stk.pop(-1)
            return tmp


    def increment(self, k: int, val: int) -> None:
        l = min(k,len(self.stk))
        for i in range(l):
            self.stk[i] += val
        



# Your CustomStack object will be instantiated and called as such:
# obj = CustomStack(maxSize)
# obj.push(x)
# param_2 = obj.pop()
# obj.increment(k,val)
```

# 394

```python
class Solution:
    def decodeString(self, s: str) -> str:
        num = '' # record number
        word = '' # record pre str
        list_num = list()
        list_word = list()
        for i in range(len(s)):
            if s[i].isdigit():
                num += s[i]
            elif s[i] == '[':
                list_num.append(int(num))
                list_word.append(word)
                num = '' # record number
                word = '' # record pre str
            elif s[i] == ']':
                pre_word = list_word.pop()
                n = list_num.pop()
                word =  pre_word + n *word
            else:
                word += s[i]
        return word
```
# 946. 验证栈序列

```python
class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        stk = list()
        n = len(pushed)
        for i in range(n):
            stk.append(pushed[i])
            while stk and popped and stk[-1] == popped[0]:
                stk.pop(-1)
                popped.pop(0)                

        if len(popped) == 0 and len(stk)==0:
            return True
        else:
            return False
```

# 队列
应用：BFS

内置队列：deque (双端队列）

## 最小栈
```python
class MinStack:

    def __init__(self):
        self.stk = list()
        self.min = list()

    def push(self, val: int) -> None:
        self.stk.append(val)
        if self.min:
            val = min(val,self.min[-1])
        self.min.append(val)


    def pop(self) -> None:
        self.stk.pop()
        self.min.pop()


    def top(self) -> int:
        return self.stk[-1]


    def getMin(self) -> int:
        return self.min[-1]


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()

```

## 克隆

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""
class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        def dfs(root,vis):
            if not root:
                return  
            if root in vis:
                return vis[root]
            new_node = Node(root.val,[])
            vis[root] = new_node
            if root.neighbors:
                for n in root.neighbors:
                    new_node.neighbors.append(dfs(n,vis))
            return new_node
        return dfs(node,dict())
```
## 岛屿数量

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def dfs(i,j,grid):

            if grid[i][j] == '0':
                return 
            grid[i][j] = '0'
            x,y = i,j
            for x,y in [[x+1,y],[x-1,y],[x,y-1],[x,y+1]]:
                if 0<=x<len(grid) and 0<=y<len(grid[0]):
                    dfs(x,y,grid)

        res = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                
                if grid[i][j] == '1':
                    res+=1
                    dfs(i,j,grid)
        return (res)

```

## 01矩阵

广度优先搜索，首先
```python
class Solution:
    from collections import deque
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        que = deque()
        seen = set()
        
        res = [ [ 0 for i in range(len(mat[0]))] for _ in range(len(mat))]
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                if mat[i][j] == 0:
                    que.append([i,j])
                    seen.add((i,j))
                    
        m, n = len(matrix), len(matrix[0])
        dist = [[0] * n for _ in range(m)]
        zeroes_pos = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == 0]
        # 将所有的 0 添加进初始队列中
        q = collections.deque(zeroes_pos)
        seen = set(zeroes_pos)


         
        while que:
            x,y = que.popleft()
            if (x,y) in seen:
                for new_x,new_y in  ([x-1,y],[x+1,y],[x,y-1],[x,y+1]):
                    if 0<=new_x<len(mat) and 0<= new_y<len(mat[0]) and (new_x,new_y) not in seen:
                        que.append([new_x,new_y])
                        res[new_x][new_y] =  res[x][y] +1
                        seen.add((new_x,new_y))
                         
        return res
```
                     

            


