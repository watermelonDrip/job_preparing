# 数组

1. 操作简单
2. 支持随机访问 （每一项都使用一个byte存储情况，基址+偏移量）


## 414. 第三大数



```python
class Solution:
    import heapq as hq
    def thirdMax(self, nums: List[int]) -> int:
        heap = list()
        for i in range(len(nums)):
            if nums[i] in heap:
                continue
            heapq.heappush(heap,nums[i])
            if len(heap)>3:
                heapq.heappop(heap)
        if len(heap)<3:
            return max(heap)
        else:
            return min(heap)
```
```python
class Solution:
    import heapq as hq
    def thirdMax(self, nums: List[int]) -> int:
        heap = list()
        if len(set(nums))<3:
            return max(nums)
        for num in set(nums):
            heappush(heap,num)
            if len(heap)>3:
                heappop(heap)
        return heap[0]
```

# 栈

 

## 150. 逆波兰表达式

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        heap = []
        for i in range(len(tokens)):
            if tokens[i].lstrip('-').isdigit(): #注意
                heap.append(int(tokens[i]))
            else:
                a = heap.pop(-1)
                b = heap.pop(-1)
                if tokens[i] == '+':
                    c = a+ b
                elif tokens[i] == '*':
                    c = a*b
                elif tokens[i] == '-':
                    c = b-a
                elif tokens[i] == '/':
                    c = b/a
                 
                heap.append(int(c))
             
        return heap[-1]
```        

## 1381.设计一个支持增量操作的栈

```python
class CustomStack:
    def __init__(self, maxSize: int):
        self.stk = []
        self.maxSize = maxSize
    def push(self, x: int) -> None:
        if len(self.stk)< self.maxSize:
            self.stk.append(x)
    def pop(self) -> int:
        if len(self.stk) == 0:
            return -1
        else:
            tmp = self.stk.pop(-1)
            return tmp
    def increment(self, k: int, val: int) -> None:
        l = min(k,len(self.stk))
        for i in range(l):
            self.stk[i] += val
# Your CustomStack object will be instantiated and called as such:
# obj = CustomStack(maxSize)
# obj.push(x)
# param_2 = obj.pop()
# obj.increment(k,val)
```

# 394. 字符串解码

```python
class Solution:
    def decodeString(self, s: str) -> str:
        num = '' # record number
        word = '' # record pre str
        list_num = list()
        list_word = list()
        for i in range(len(s)):
            if s[i].isdigit():
                num += s[i]
            elif s[i] == '[':
                list_num.append(int(num))
                list_word.append(word)
                num = '' # record number
                word = '' # record pre str
            elif s[i] == ']':
                pre_word = list_word.pop()
                n = list_num.pop()
                word =  pre_word + n *word
            else:
                word += s[i]
        return word
```
# 946. 验证栈序列

```python
class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        stk = list()
        n = len(pushed)
        for i in range(n):
            stk.append(pushed[i])
            while stk and popped and stk[-1] == popped[0]:
                stk.pop(-1)
                popped.pop(0)                

        if len(popped) == 0 and len(stk)==0:
            return True
        else:
            return False
```

# 队列

应用：BFS

内置队列：deque (collections包里的，双端队列）

## 最小栈

```python
class MinStack:
    def __init__(self):
        self.stk = list()
        self.min = list()
    def push(self, val: int) -> None:
        self.stk.append(val)
        if self.min:
            val = min(val,self.min[-1])
        self.min.append(val)
    def pop(self) -> None:
        self.stk.pop()
        self.min.pop()
    def top(self) -> int:
        return self.stk[-1]
    def getMin(self) -> int:
        return self.min[-1]

# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```

## 克隆

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""
class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        def dfs(root,vis):
            if not root:
                return  
            if root in vis:
                return vis[root]
            new_node = Node(root.val,[])
            vis[root] = new_node
            if root.neighbors:
                for n in root.neighbors:
                    new_node.neighbors.append(dfs(n,vis))
            return new_node
        return dfs(node,dict())
```

## 岛屿数量

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def dfs(i,j,grid):
            if grid[i][j] == '0':
                return 
            grid[i][j] = '0'
            x,y = i,j
            for x,y in [[x+1,y],[x-1,y],[x,y-1],[x,y+1]]:
                if 0<=x<len(grid) and 0<=y<len(grid[0]):
                    dfs(x,y,grid)
        res = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    res+=1
                    dfs(i,j,grid)
        return (res)
```

## 01 矩阵
 
```python
class Solution:
    from collections import deque
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        que = deque()
        seen = set()
        res = [ [ 0 for i in range(len(mat[0]))] for _ in range(len(mat))]
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                if mat[i][j] == 0:
                    que.append([i,j])
                    seen.add((i,j))
        m, n = len(matrix), len(matrix[0])
        dist = [[0] * n for _ in range(m)]
        zeroes_pos = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == 0]
        # 将所有的 0 添加进初始队列中
        q = collections.deque(zeroes_pos)
        seen = set(zeroes_pos)
        while que:
            x,y = que.popleft()
            if (x,y) in seen:
                for new_x,new_y in  ([x-1,y],[x+1,y],[x,y-1],[x,y+1]):
                    if 0<=new_x<len(mat) and 0<= new_y<len(mat[0]) and (new_x,new_y) not in seen:
                        que.append([new_x,new_y])
                        res[new_x][new_y] =  res[x][y] +1
                        seen.add((new_x,new_y))
        return res
```
                     
## 单调栈

```python
class Solution: (找第一个比i小的)
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights = [0] + heights + [0]
        stk = list() # 单调递增
        res = 0
        for i in range(len(heights)):
            while stk and heights[i] < heights[stk[-1]]:
                tmp = stk.pop(-1)
                res = max(res, heights[tmp]*( i - stk[-1]-1))
            stk.append(i)
        return res
```


```python
class Solution: (找到第一个比i大）
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        stk = [] # 单调递减
        res = [0]*( len(temperatures))
        for i in range(len(temperatures)):
            while stk and temperatures[i] > temperatures[stk[-1]]: 
                tmp = stk.pop(-1)
                res[tmp] = i - tmp
            stk.append(i)
        return res
```

## 402. 移掉 K 位数字
```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        stk = list() # 找到第一个比i小的
    # 单调增
        n = len(num)-k
        if len(num) <=k:
            return '0'
        for i in range(len(num)):
            while stk and k and stk[-1] > num[i]:
                tmp = stk.pop()
                k -=1
            stk.append(num[i])
        return ''.join(stk[:]).lstrip('0') or '0'
```
## 20. 有效括号


```python
class Solution:
    def isValid(self, s: str) -> bool:
        dict_s ={1:'(',2:')',3:'[',4:']',5:'{',6:'}'}
        stk = list()
        if len(s)%2:
            return False
        for i in range(len(s)):
            if s[i] in ['(','[','{']:
                stk.append(s[i])
            else:
                if len(stk) == 0:
                    return False
                tmp = stk.pop(-1)
                if s[i] == dict_s[2] and tmp == dict_s[1]:
                    continue
                elif s[i] == dict_s[4] and tmp == dict_s[3]:
                    continue                    
                elif s[i] == dict_s[6] and tmp == dict_s[5]:
                    continue          
                else:
                    return False
        return len(stk) == 0
```
## 分桶&计数

### 字母异位数

```python
class Solution:
    from collections import defaultdict
     
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        dict_str = defaultdict(list)
        for s in strs:
            s_key = [0]*26
            for i in range(len(s)):
                s_key[ord(s[i])-ord('a')]+=1
            
            dict_str[tuple(s_key)].append(s)
        
        return list(  dict_str.values())
```
### 适龄朋友
```python
class Solution:
    def numFriendRequests(self, ages: List[int]) -> int:
        bucket = [0]*121
        res =0

        for i in range(len(ages)):
            bucket[ages[i]]+=1
        pre = [0]*121
        for i in range(len(bucket)):
            pre[i] = pre[i-1]+bucket[i]

        for j in range(15,121):
            if bucket[j]<=0:
                continue
            lower = int( 0.5*j+8) # 如果转换的是float函数，那么转换结果是向0的方向靠近，而不是四舍五入

            upper = j
            res += bucket[j]*(pre[upper] - pre[lower-1]-1) #最后的1是本身。
        return res
```




            


