414. 第三大数
```python
class Solution:
    import heapq as hq
    def thirdMax(self, nums: List[int]) -> int:
        heap = list()
        for i in range(len(nums)):
            if nums[i] in heap:
                continue
            heapq.heappush(heap,nums[i])
            if len(heap)>3:
                heapq.heappop(heap)
        if len(heap)<3:
            return max(heap)
        else:
            return min(heap)
```
```python
class Solution:
    import heapq as hq
    def thirdMax(self, nums: List[int]) -> int:
        heap = list()
        if len(set(nums))<3:
            return max(nums)
        for num in set(nums):
            heappush(heap,num)
            if len(heap)>3:
                heappop(heap)
        return heap[0]
```
150. 逆波兰表达式
```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        heap = []
        for i in range(len(tokens)):
            if tokens[i].lstrip('-').isdigit(): #注意
                heap.append(int(tokens[i]))
            else:
                a = heap.pop(-1)
                b = heap.pop(-1)
                if tokens[i] == '+':
                    c = a+ b
                elif tokens[i] == '*':
                    c = a*b
                elif tokens[i] == '-':
                    c = b-a
                elif tokens[i] == '/':
                    c = b/a
                 
                heap.append(int(c))
             
        return heap[-1]
```        

1381.
```python
class CustomStack:

    def __init__(self, maxSize: int):
        self.stk = []
        self.maxSize = maxSize

    def push(self, x: int) -> None:
        if len(self.stk)< self.maxSize:
            self.stk.append(x)
        



    def pop(self) -> int:
        if len(self.stk) == 0:
            return -1
        else:
            tmp = self.stk.pop(-1)
            return tmp


    def increment(self, k: int, val: int) -> None:
        l = min(k,len(self.stk))
        for i in range(l):
            self.stk[i] += val
        



# Your CustomStack object will be instantiated and called as such:
# obj = CustomStack(maxSize)
# obj.push(x)
# param_2 = obj.pop()
# obj.increment(k,val)
```

# 394

```python
class Solution:
    def decodeString(self, s: str) -> str:
        num = '' # record number
        word = '' # record pre str
        list_num = list()
        list_word = list()
        for i in range(len(s)):
            if s[i].isdigit():
                num += s[i]
            elif s[i] == '[':
                list_num.append(int(num))
                list_word.append(word)
                num = '' # record number
                word = '' # record pre str
            elif s[i] == ']':
                pre_word = list_word.pop()
                n = list_num.pop()
                word =  pre_word + n *word
            else:
                word += s[i]
        return word
```
# 946. 验证栈序列

```python
class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        stk = list()
        n = len(pushed)
        for i in range(n):
            stk.append(pushed[i])
            while stk and popped and stk[-1] == popped[0]:
                stk.pop(-1)
                popped.pop(0)                

        if len(popped) == 0 and len(stk)==0:
            return True
        else:
            return False
```

# 队列
应用：BFS

内置队列：deque (双端队列）

## 最小栈
```python
class MinStack:

    def __init__(self):
        self.stk = list()
        self.min = list()

    def push(self, val: int) -> None:
        self.stk.append(val)
        if self.min:
            val = min(val,self.min[-1])
        self.min.append(val)


    def pop(self) -> None:
        self.stk.pop()
        self.min.pop()


    def top(self) -> int:
        return self.stk[-1]


    def getMin(self) -> int:
        return self.min[-1]


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()

```

## 克隆

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""
class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        def dfs(root,vis):
            if not root:
                return  
            if root in vis:
                return vis[root]
            new_node = Node(root.val,[])
            vis[root] = new_node
            if root.neighbors:
                for n in root.neighbors:
                    new_node.neighbors.append(dfs(n,vis))
            return new_node
        return dfs(node,dict())
```
