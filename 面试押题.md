# 🌞  morning ～ 今天是刷题 PK 第4天！
小助理为大家准备了以下早报内容 👇

📢  今日押题
【难度：简单】160. 相交链表 
【难度：中等】142. 环形链表 II
【难度：困难】23. 合并K个升序链表

## 相交链表
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        cur_A = headA
        cur_B = headB
        while cur_A != cur_B:
            if cur_A == None:
                cur_A = headB
            else:
                cur_A = cur_A.next

            if cur_B == None:
                cur_B = headA
            else:
                cur_B = cur_B.next

      
        return cur_A

```

## 环形链表 II
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head or not head.next or not head.next.next:
            return None

        slow = head.next
        fast = head.next.next
        while slow != fast:
            slow = slow.next
            fast = fast.next.next
            if not fast or not fast.next:
                return None
        fast = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return fast 

```

## 23. 合并K个升序链表

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if not lists:
            return None
        new = ListNode()
        dummy = new
        heap = list()
        for i in range(len(lists)):
            if not lists[i]:
                continue
            heapq.heappush(heap,(lists[i].val,i))
            lists[i] = lists[i].next
            
        while heap:
            value,idx= heapq.heappop(heap)
            
            dummy.next = ListNode(value)
            dummy = dummy.next
            
            if lists[idx]:
                heapq.heappush(heap,(lists[idx].val,idx))
                lists[idx] = lists[idx].next
           
        return new.next 
```
