# ğŸŒ  morning ï½ ä»Šå¤©æ˜¯åˆ·é¢˜ PK ç¬¬4å¤©ï¼
å°åŠ©ç†ä¸ºå¤§å®¶å‡†å¤‡äº†ä»¥ä¸‹æ—©æŠ¥å†…å®¹ ğŸ‘‡

ğŸ“¢  ä»Šæ—¥æŠ¼é¢˜
ã€éš¾åº¦ï¼šç®€å•ã€‘160. ç›¸äº¤é“¾è¡¨ 
ã€éš¾åº¦ï¼šä¸­ç­‰ã€‘142. ç¯å½¢é“¾è¡¨ II
ã€éš¾åº¦ï¼šå›°éš¾ã€‘23. åˆå¹¶Kä¸ªå‡åºé“¾è¡¨

## ç›¸äº¤é“¾è¡¨
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        cur_A = headA
        cur_B = headB
        while cur_A != cur_B:
            if cur_A == None:
                cur_A = headB
            else:
                cur_A = cur_A.next

            if cur_B == None:
                cur_B = headA
            else:
                cur_B = cur_B.next

      
        return cur_A

```

## ç¯å½¢é“¾è¡¨ II
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head or not head.next or not head.next.next:
            return None

        slow = head.next
        fast = head.next.next
        while slow != fast:
            slow = slow.next
            fast = fast.next.next
            if not fast or not fast.next:
                return None
        fast = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return fast 

```

## 23. åˆå¹¶Kä¸ªå‡åºé“¾è¡¨

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if not lists:
            return None
        new = ListNode()
        dummy = new
        heap = list()
        for i in range(len(lists)):
            if not lists[i]:
                continue
            heapq.heappush(heap,(lists[i].val,i))
            lists[i] = lists[i].next
            
        while heap:
            value,idx= heapq.heappop(heap)
            
            dummy.next = ListNode(value)
            dummy = dummy.next
            
            if lists[idx]:
                heapq.heappush(heap,(lists[idx].val,idx))
                lists[idx] = lists[idx].next
           
        return new.next 
```

# ğŸŒ morning ï½ ä»Šå¤©æ˜¯åˆ·é¢˜ PK ç¬¬ 5âƒ£ï¸ å¤©ï¼
âš ï¸å°åŠ©ç†æ¸©é¦¨æç¤ºï¼šåˆ·é¢˜ä¸æ»¡ 2 å¤©ä¼šè¢«è¸¢å‡ºæˆ˜é˜Ÿå“¦
å°åŠ©ç†ä¸ºå¤§å®¶å‡†å¤‡äº†ä»¥ä¸‹æ—©æŠ¥å†…å®¹ ğŸ‘‡

ğŸ“¢ ä»Šæ—¥æŠ¼é¢˜
ã€éš¾åº¦ï¼šç®€å•ã€‘1. ä¸¤æ•°ä¹‹å’Œ  
ã€éš¾åº¦ï¼šç®€å• ã€‘217. å­˜åœ¨é‡å¤å…ƒç´   
ã€éš¾åº¦ï¼šä¸­ç­‰ ã€‘146. LRU ç¼“å­˜  

## ä¸¤æ•°ä¹‹å’Œ  

```python
class Solution: #æšä¸¾æš´åŠ›
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        list_nums = list()
        for idx, key in enumerate(nums):
            list_nums.append([key,idx])
        list_nums = sorted(list_nums, key = lambda x:x[0])
        left = 0
        right = len(nums)-1
      
        while left<right:
            if list_nums[left][0] + list_nums[right][0] > target:
              
                right-=1
            elif list_nums[left][0] + list_nums[right][0] < target:
                left+=1
            else:
                return [list_nums[left][1],list_nums[right][1]]
```


```
class Solution: #å­—å…¸
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashtable = dict()
        for i, num in enumerate(nums):
            if target - num in hashtable:
                return [hashtable[target - num], i]
            hashtable[nums[i]] = i
        return []
```

## LRU ç¼“å­˜  

``` 














