# ðŸŒž  morning ï½ž ä»Šå¤©æ˜¯åˆ·é¢˜ PK ç¬¬4å¤©ï¼
å°åŠ©ç†ä¸ºå¤§å®¶å‡†å¤‡äº†ä»¥ä¸‹æ—©æŠ¥å†…å®¹ ðŸ‘‡

ðŸ“¢  ä»Šæ—¥æŠ¼é¢˜
ã€éš¾åº¦ï¼šç®€å•ã€‘160. ç›¸äº¤é“¾è¡¨ 
ã€éš¾åº¦ï¼šä¸­ç­‰ã€‘142. çŽ¯å½¢é“¾è¡¨ II
ã€éš¾åº¦ï¼šå›°éš¾ã€‘23. åˆå¹¶Kä¸ªå‡åºé“¾è¡¨

## ç›¸äº¤é“¾è¡¨
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        cur_A = headA
        cur_B = headB
        while cur_A != cur_B:
            if cur_A == None:
                cur_A = headB
            else:
                cur_A = cur_A.next

            if cur_B == None:
                cur_B = headA
            else:
                cur_B = cur_B.next

      
        return cur_A

```

## çŽ¯å½¢é“¾è¡¨ II
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head or not head.next or not head.next.next:
            return None

        slow = head.next
        fast = head.next.next
        while slow != fast:
            slow = slow.next
            fast = fast.next.next
            if not fast or not fast.next:
                return None
        fast = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return fast 

```

## 23. åˆå¹¶Kä¸ªå‡åºé“¾è¡¨

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if not lists:
            return None
        new = ListNode()
        dummy = new
        heap = list()
        for i in range(len(lists)):
            if not lists[i]:
                continue
            heapq.heappush(heap,(lists[i].val,i))
            lists[i] = lists[i].next
            
        while heap:
            value,idx= heapq.heappop(heap)
            
            dummy.next = ListNode(value)
            dummy = dummy.next
            
            if lists[idx]:
                heapq.heappush(heap,(lists[idx].val,idx))
                lists[idx] = lists[idx].next
           
        return new.next 
```
